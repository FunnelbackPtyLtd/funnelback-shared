<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd">
<book>
	<bookinfo>
		<title>Reference Documentation</title>

		<productname>Funnelback Public UI</productname>

		<releaseinfo>2011</releaseinfo>

		<mediaobject>
			<imageobject role="fo">
				<imagedata align="center" fileref="images/logo-pdf.png"
					format="PNG" width="240" />
			</imageobject>
		</mediaobject>

		<authorgroup>
			<author>
				<firstname>Nicolas</firstname>
				<surname>Guillaumin</surname>
				<email>nguillaumin@funnelback.com</email>
			</author>
		</authorgroup>

		<copyright>
			<year>2011</year>
			<holder>Funnelback</holder>
		</copyright>

	</bookinfo>

	<toc></toc>
	
	<chapter id="introduction">
		<title>Introduction</title>
		
		<para>
			This documentation intends to be the missing link between the product documentation (for users) and the code.
			Most of what's written here is coming from reverse-engineering the Perl code to write the Java Public UI.
			Since sometimes code comments weren't enough, this doco has been created to explain why and how some features
			has been developed.
		</para>
	</chapter>
	
	<chapter id="meta-dates">
		<title>Date parameters (<literal>meta_(d|d1|d2|d3|d4|w1|w2|x|y|z)</literal>)</title>

		<para>The Public UI allows passing date contraints to the query, expressed as <literal>meta_*</literal> parameters.</para>
		<para><literal>d, d1, d2, d3, d4</literal> are documented in the product doco, but <literal>w1, w2, x, y, z</literal> aren't.</para>
		
		<section>
			<title>Date constraints (<literal>d, d1, d2, d3, d4</literal>)</title>
			<para>(Check the product doco for details about these parameters).</para>
			
			<para>
			Each date constraint can be passed either as a specific date, such as <literal>meta_d3=01Jan2010</literal>, or as three separate
			components: <literal>meta_d3day=1, meta_d3month=1, meta_d3year=2010</literal>. Each component is optional, meaning that it's possible
			to have a date like &quot;201001&quot; for January 2010.
			</para>
			
			<para>
				Dates are passed as-is to PADRE, except for <literal>d3</literal> and <literal>d4</literal> parameters: Those one means
				&quot;greater than or equal&quot; and &quot;lesser than or equal&quot;. PADRE doesn't interpret them directly so the Public UI
				has to remove or add a day to the provided date to simulate this.
				
				<note>
					<para>
						There is no specific constraint on date formats, so we try to parse using various patterns. If the parsing fails the
						constraint is simply ignored.
					</para>
				</note>
			</para>
		</section>
		
		<section>
			<title>Text-based date constraints (<literal>x, y, z</literal>)</title>
			<para>
				As seen on the Perl code there is some processing related to text-based date constraint and <literal>x, y, z</literal> metadata classes:
				<programlisting language="perl">
<![CDATA[for ( "d", "d1", "d2", "d3", "d4", "w1", "w2", "x", "y", "z" ) {
    my $year_param  = "meta_" . $_ . "year";
    my $month_param = "meta_" . $_ . "month";
    my $day_param   = "meta_" . $_ . "day";
    my $year        = Funnelback::CGIExtras::get_cgi_param_from_hash( $year_param, Funnelback::CGIExtras::TYPE_NUMERIC, $params_hash );
    my $month       = Funnelback::CGIExtras::get_cgi_param_from_hash( $month_param, Funnelback::CGIExtras::TYPE_ALPHA, $params_hash );
    my $day         = Funnelback::CGIExtras::get_cgi_param_from_hash( $day_param, Funnelback::CGIExtras::TYPE_NUMERIC, $params_hash );
    if ( $year and $month and $day ) {
    	$params_hash->{"meta_$_"} = "$day$month$year";
    }
    elsif ( $year and $month ) {
    	$params_hash->{"meta_$_"} = "$month$year";
    }
    elsif ($year) {
    	$params_hash->{"meta_$_"} = "$year";
    }

    # Process the text date fields
    if ( ( $year or $month or $day ) and $_ =~ /[xyz]/ ) {
        my $value = Funnelback::CGIExtras::get_cgi_param_from_hash("meta_$_", Funnelback::CGIExtras::TYPE_UNKNOWN, $params_hash);
        if ( $day and $value ) {
            push @padrequery, "$_:" . $value;
        }
        else {
            push @padrequery, "$_:*" . $value;
        }
    }
}]]>
				</programlisting>
			</para>
			
			<para>
				Unfortunately nobody was able to figure out what that was supposed to do (Check <ulink url="https://jira.funnelback.com/browse/FUN-65">FUN-65</ulink>)
				so it has NOT been re-implemented.
			</para>
		</section>
		
		<section>
			<title>Event search (<literal>w1, w2</literal>)</title>
			<para>(Check the PADRE doco for details about this feature.)</para>
			
			<para>The idea is to process any existing <literal>meta_w1</literal> or <literal>meta_w2</literal> parameter into an event search query.</para>
			<para>
				If any of those parameters exist, they must be transformed in <literal>% w&gt;[value of w1]&lt;[value of w2]</literal>.
				The <literal>%</literal> is a flag that switch PADRE to event search mode, and the following expression gives the event search range.
			</para>
			
			<para>The value of the <literal>w1, w2</literal> is supposed to be a correct date that is passed as-is to PADRE (no parsing).</para>
		</section>
	</chapter>
	
	<chapter id="meta-parameters-operators">
		<title>Meta parameters operators (<literal>or, sand, and, ...</literal>)</title>
		
		<para>
			Two possible syntaxes: <literal>meta_&lt;md&gt;_&lt;operator&gt;</literal> or <literal>query_&lt;operator&gt;</literal>.
			These parameters are transformed in query expressions using the PADRE query language.
		</para>
		
		<para>
			Each operator has been implemented as a Java function:
			<programlisting language="java">
<![CDATA[...

public String orsand(final String md, final String values[]) {
	String[] data = values;
	if (md != null) {
		data = prefixStrings(values, md+":");
	}	
	return "|[" + StringUtils.join(data, " ") + "]";
}

public String or(final String md, final String values[]) {
	String[] data = values;
	if (md != null) {
		data = prefixStrings(values, md+":");
	}	
	return "[" + StringUtils.join(data, " ") + "]";
}

...]]>
			</programlisting>
			
			The operator to use is parsed from the parameter name (Eg. <literal>meta_b_orsand</literal> => <literal>orsand</literal>) and the
			corresponding Java method is called by reflection.
			This way, adding new operators is easy: Just code the new corresponding function and add the operator name to the list of valid operators.
		</para>
	</chapter>
	
	<chapter id="environment-variables">
		<title>Environment variables</title>
		
		<para>
			PADRE uses some environment variables which were previously provided by the CGI stack (<literal>REMOTE_USER, HTTP_HOST, ...)</literal>).
			An <literal>InputProcessor</literal> has been developed to fetch the correct values from the <literal>HttpServletRequest</literal> object
			and repass them to PADRE.
		</para>
	</chapter>
	
	<chapter id="passthrough-parameters">
		<title>Pass-through parameters</title>
		
		<para>
			A lot of query string parameters are used by PADRE, but never used by the Public UI layer (Examples: <literal>num_rank, start_rank</literal>, any
			query processor option, etc.).
			An <literal>InputProcessor</literal> has been developed to just repass along any parameters not used directly by the Public UI (Such as 
			<literal>collection, query</literal>, etc.).
		</para>
	</chapter>
	
	<chapter id="meta-aliases">
		<title>Meta classes aliases (<literal>site:, allinurl:, link:, filetype:</literal>)</title>
		
		<para>
			This operators as just aliases for some metadata classes:
			
			<table>
				<title>Mapping</title>
				<tgroup cols="2" align="center">
					<thead>
						<row>
							<entry>Operator</entry>
							<entry>Metadata class</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>link:</entry>
							<entry>h</entry>
						</row>
						<row>
							<entry>site:</entry>
							<entry>u</entry>
						</row>
						<row>
							<entry>filetype:</entry>
							<entry>f</entry>
						</row>
						<row>
							<entry>allinurl:</entry>
							<entry>v</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</para>
	</chapter>
	
	<chapter id="clive-parameters">
		<title><literal>clive</literal> parameters</title>
		
		<para>The <literal>clive</literal> parameter is used to contraint search to specific components of a meta collection.</para>
		
		<para>
			The Public UI uses &quot;human readable&quot; <literal>clive</literal> parameters (collection names) but PADRE only understand the internal
			&quot;technical&quot; version: An integer corresponding to a line index in the <literal>meta.cfg</literal> file.
		</para>
		
		<para>
			Consider the following <literal>meta.cfg</literal> file:
			
			<programlisting>
<![CDATA[#
# Filename: C:\funnelback\conf\test-meta\meta.cfg
# Last Update: Wed Dec 15 16:26:17 2010
#
intranet
trim
fileshare]]>		
			</programlisting>
			
			A valid <literal>clive</literal> parameter in the Public UI could be: <literal>clive=intranet,trim</literal>, however PADRE will only understand
			<literal>clive=0,1</literal>. For this reason an <literal>InputProcessor</literal> has been developed to do the conversion.
		</para>
		
		<para>
			As opposite to the Perl UI there is no need to convert &quot;back&quot; from the integer version to the human-friendly version since both
			versions are stored and available from the data model (<literal>SearchQuestion</literal>)
		</para>
	</chapter>

</book>