<?xml version="1.0" encoding="UTF-8"?>
<part xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en" id="implementation-notes">
	<title>Implementation notes</title>
	
	<chapter id="meta-dates">
		<title>Date parameters (<literal>meta_(d|d1|d2|d3|d4|w1|w2|x|y|z)</literal>)</title>

		<para>The Public UI allows passing date contraints to the query, expressed as <literal>meta_*</literal> parameters.</para>
		<para><literal>d, d1, d2, d3, d4</literal> are documented in the product doco, but <literal>w1, w2, x, y, z</literal> aren't.</para>
		
		<section id="meta-dates-date-constraints">
			<title>Date constraints (<literal>d, d1, d2, d3, d4</literal>)</title>
			<para>(Check the product doco for details about these parameters).</para>
			
			<para>
			Each date constraint can be passed either as a specific date, such as <literal>meta_d3=01Jan2010</literal>, or as three separate
			components: <literal>meta_d3day=1, meta_d3month=1, meta_d3year=2010</literal>. Each component is optional, meaning that it's possible
			to have a date like &quot;201001&quot; for January 2010.
			</para>
			
			<para>
				Dates are passed as-is to PADRE, except for <literal>d3</literal> and <literal>d4</literal> parameters: Those one means
				&quot;greater than or equal&quot; and &quot;lesser than or equal&quot;. PADRE doesn't interpret them directly so the Public UI
				has to remove or add a day to the provided date to simulate this.
				
				<note>
					<para>
						There is no specific constraint on date formats, so we try to parse using various patterns. If the parsing fails the
						constraint is simply ignored.
					</para>
				</note>
			</para>
		</section>
		
		<section id="meta-dates-text-based-date-constraints">
			<title>Text-based date constraints (<literal>x, y, z</literal>)</title>
			<para>
				As seen on the Perl code there is some processing related to text-based date constraint and <literal>x, y, z</literal> metadata classes:
				<programlisting language="perl">
<![CDATA[for ( "d", "d1", "d2", "d3", "d4", "w1", "w2", "x", "y", "z" ) {
    my $year_param  = "meta_" . $_ . "year";
    my $month_param = "meta_" . $_ . "month";
    my $day_param   = "meta_" . $_ . "day";
    my $year        = Funnelback::CGIExtras::get_cgi_param_from_hash( $year_param, Funnelback::CGIExtras::TYPE_NUMERIC, $params_hash );
    my $month       = Funnelback::CGIExtras::get_cgi_param_from_hash( $month_param, Funnelback::CGIExtras::TYPE_ALPHA, $params_hash );
    my $day         = Funnelback::CGIExtras::get_cgi_param_from_hash( $day_param, Funnelback::CGIExtras::TYPE_NUMERIC, $params_hash );
    if ( $year and $month and $day ) {
    	$params_hash->{"meta_$_"} = "$day$month$year";
    }
    elsif ( $year and $month ) {
    	$params_hash->{"meta_$_"} = "$month$year";
    }
    elsif ($year) {
    	$params_hash->{"meta_$_"} = "$year";
    }

    # Process the text date fields
    if ( ( $year or $month or $day ) and $_ =~ /[xyz]/ ) {
        my $value = Funnelback::CGIExtras::get_cgi_param_from_hash("meta_$_", Funnelback::CGIExtras::TYPE_UNKNOWN, $params_hash);
        if ( $day and $value ) {
            push @padrequery, "$_:" . $value;
        }
        else {
            push @padrequery, "$_:*" . $value;
        }
    }
}]]>
				</programlisting>
			</para>
			
			<para>
				Unfortunately nobody was able to figure out what that was supposed to do (Check <ulink url="" type="issue">FUN-65</ulink>)
				so it has NOT been re-implemented.
			</para>
		</section>
		
		<section id="event-search">
			<title>Event search (<literal>w1, w2</literal>)</title>
			<para>(Check the PADRE doco for details about this feature.)</para>
			
			<para>The idea is to process any existing <literal>meta_w1</literal> or <literal>meta_w2</literal> parameter into an event search query.</para>
			<para>
				If any of those parameters exist, they must be transformed in <literal>% w&gt;[value of w1]&lt;[value of w2]</literal>.
				The <literal>%</literal> is a flag that switch PADRE to event search mode, and the following expression gives the event search range.
			</para>
			
			<para>The value of the <literal>w1, w2</literal> is supposed to be a correct date that is passed as-is to PADRE (no parsing).</para>
		</section>
	</chapter>
	
	<chapter id="meta-parameters-operators">
		<title>Meta parameters operators (<literal>or, sand, and, ...</literal>)</title>
		
		<para>
			Two possible syntaxes: <literal>meta_&lt;md&gt;_&lt;operator&gt;</literal> or <literal>query_&lt;operator&gt;</literal>.
			These parameters are transformed in query expressions using the PADRE query language.
		</para>
		
		<para>
			Each operator has been implemented as a Java function:
			<programlisting language="java">
<![CDATA[...

public String orsand(final String md, final String values[]) {
	String[] data = values;
	if (md != null) {
		data = prefixStrings(values, md+":");
	}	
	return "|[" + StringUtils.join(data, " ") + "]";
}

public String or(final String md, final String values[]) {
	String[] data = values;
	if (md != null) {
		data = prefixStrings(values, md+":");
	}	
	return "[" + StringUtils.join(data, " ") + "]";
}

...]]>
			</programlisting>
			
			The operator to use is parsed from the parameter name (Eg. <literal>meta_b_orsand</literal> => <literal>orsand</literal>) and the
			corresponding Java method is called by reflection.
			This way, adding new operators is easy: Just code the new corresponding function and add the operator name to the list of valid operators.
		</para>
	</chapter>
	
	<chapter id="environment-variables">
		<title>Environment variables</title>
		
		<para>
			PADRE uses some environment variables which were previously provided by the CGI stack (<envar>REMOTE_USER</envar>, <envar>HTTP_HOST</envar>, ...).
			An <literal>InputProcessor</literal> has been developed to fetch the correct values from the <literal>HttpServletRequest</literal> object
			and repass them to PADRE.
		</para>
	</chapter>
	
	<chapter id="passthrough-parameters">
		<title>Pass-through parameters</title>
		
		<para>
			A lot of query string parameters are used by PADRE, but never used by the Public UI layer (Examples: <literal>num_rank, start_rank</literal>, any
			query processor option, etc.).
			An <literal>InputProcessor</literal> has been developed to just repass along any parameters not used directly by the Public UI (Such as 
			<literal>collection, query</literal>, etc.).
		</para>
	</chapter>
	
	<chapter id="meta-aliases">
		<title>Meta classes aliases (<literal>site:, allinurl:, link:, filetype:</literal>)</title>
		
		<para>
			This operators as just aliases for some metadata classes:
			
			<table>
				<title>Mapping</title>
				<tgroup cols="2" align="center">
					<thead>
						<row>
							<entry>Operator</entry>
							<entry>Metadata class</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>link:</entry>
							<entry>h</entry>
						</row>
						<row>
							<entry>site:</entry>
							<entry>u</entry>
						</row>
						<row>
							<entry>filetype:</entry>
							<entry>f</entry>
						</row>
						<row>
							<entry>allinurl:</entry>
							<entry>v</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</para>
	</chapter>
	
	<chapter id="clive-parameters">
		<title><literal>clive</literal> parameters</title>
		
		<para>The <literal>clive</literal> parameter is used to contraint search to specific components of a meta collection.</para>
		
		<para>
			The Public UI uses &quot;human readable&quot; <literal>clive</literal> parameters (collection names) but PADRE only understand the internal
			&quot;technical&quot; version: An integer corresponding to a line index in the <literal>meta.cfg</literal> file.
		</para>
		
		<para>
			Consider the following <literal>meta.cfg</literal> file:
			
			<programlisting>
<![CDATA[#
# Filename: C:\funnelback\conf\test-meta\meta.cfg
# Last Update: Wed Dec 15 16:26:17 2010
#
intranet
trim
fileshare]]>		
			</programlisting>
			
			A valid <literal>clive</literal> parameter in the Public UI could be: <literal>clive=intranet,trim</literal>, however PADRE will only understand
			<literal>clive=0,1</literal>. For this reason an <literal>InputProcessor</literal> has been developed to do the conversion.
		</para>
		
		<para>
			As opposite to the Perl UI there is no need to convert &quot;back&quot; from the integer version to the human-friendly version since both
			versions are stored and available from the data model (<literal>SearchQuestion</literal>)
		</para>
	</chapter>
	
	<chapter id="synonyms">
		<title>Synonyms</title>
		
		<para>
			It has been decided that the synonyms feature will be implemented in PADRE, instead of re-implemting it in the Java UI.
			Please check <ulink url="" type="issue">FUN-3368</ulink> for the details.
		</para>
	</chapter>
	
	<chapter id="pseudo-live-links">
		<title>Pseudo live links</title>
		
		<para>
			Some collection types provides &quot;fake&quot; live URLs for their results. It's for example the case for database collection, or TRIM collections because
			there is no URL associated to these kind of data.
			However we must provide a &quot;display&quot; link on the Public UI for each result, to give the user access to the information. Depending of the collection
			type this display link will for example display an HTML representation of a DB record (database collections), or open the TRIM client software (TRIM collections).
		</para>
		
		<para>
			An <literal>InputProcessor</literal> has been developed for this purpose. You'll note that fixing the live links doesn't depend of the <emphasis>type of the collection</emphasis>
			being requested, but depends on the <emphasis>type of collection for each result</emphasis>. This is due to meta collections: A meta collection can have multiple components
			of various types (trim, database, web, filecopy ...) so fixing the live links should be done differently for each result, depending of which collection the result belongs to.
		</para>
	</chapter>
	
	<chapter id="contextual-navigation">
		<title>Contextual Navigation</title>
		
		<para>
			The Java UI doesn't have much things to do for contextual navigation as most of the work is done by PADRE.
			The only note concerns the way PADRE output is parsed: Some things in PADRE XML output seems completely unused. For example:
			
			<programlisting language="xml">
<![CDATA[<contextual_navigation>
	<search_terms>king</search_terms>
	<cluster_nav level="0" url="profile=_default_preview&amp;xml=&amp;collection=Se2-Reporting-ContextualNav&amp;query=king">king</cluster_nav>
	<category name="topic" more="0">
		<cluster href="?profile=_default_preview&amp;xml=&amp;collection=Se2-Reporting-ContextualNav&amp;query=%60King%20Henry%60" count="33">...Henry</cluster>
		[...]
		<more_link label="topic">/search/padre-sw.cgi?profile=_default_preview&amp;xml=&amp;collection=Se2-Reporting-ContextualNav&amp;query=king&amp;topic.max_clusters=40</more_link>
	</category>
	[...]
</contextual_navigation>
]]>		
			</programlisting>
			
			In this example PADRE output, I couldn't see any use for the <literal>more="0"</literal> attribute (In fact it seems to be hardcoded to zero in the PADRE source.). It's
			still parsed by the PADRE output parser, but is not used anywhere.
			In the same fashion the <literal>label="topic"</literal> attribute in the <literal>&lt;more_link&gt;</literal> tag seems a repetition since it's in a &lt;category&lt; tag
			which already have a <literal>name="topic"</literal> attribute. It seemed unused in the Perl UI so it's not parsed by the Java UI (only the tag contents, the link URL, is).
		</para>
		
		<para>
			Moreover, a simple URL transformation is performed on the output for the <literal>&lt;more_link&gt;</literal> tags. The URL starts with a hardcoded path such as
			<literal>/search/padre-sw.cgi</literal>. This is simply removed.
		</para>
	</chapter>
	
	<chapter id="cgi-transforms">
		<title>CGI Transforms</title>
		
		<section id="cgi-transforms-overview">
			<title>Overview</title>
			<para>
				CGI Transforms in the Perl UI allowed users to add/change/remove query string parameters/values depending of a configuration file (See the product doco for more details).
				Re-implementing this behavior should be done at the top-level entry point in order to be transparent to the rest of the system. Ideally it should take place in a
				<literal>ServletFilter</literal> or a Spring interceptor (but keeping in mind that it should be configurable per-collection).
				Unfortunately the <literal>HttpServletRequest</literal> object from J2EE is immutable, meaning that we can't just add/change/remove Parameters by manipulating the request
				(There is no <literal>setParameter()</literal> or <literal>removeParameter()</literal> in the <literal>HttpServletRequest</literal> class).
			</para>
			
			<para>
				Using <ulink url="http://code.google.com/p/urlrewritefilter">URLRewriteFilter</ulink> has been investigated but it doesn't deal properly with query string parameters
				(See <ulink url="https://groups.google.com/d/topic/urlrewrite/oHcnjCVF_ss/discussion">here</ulink> and
				<ulink url="https://groups.google.com/d/topic/urlrewrite/6jWgBh452P0/discussion">here</ulink>) probably because of the aforementioned difficulty.
			</para>
			
			<para>
				The chosen approach is to write a <literal><ulink url="http://download.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequestWrapper.html">HttpServletRequestWrapper</ulink></literal>
				that will override the methods related to getting request parameters to &quot;simulate&quot; the fact that some parameters have been altered. This seems to be the recommended way
				of manipulating a request object.
			</para>
			
			<para>This wrapper is used with a servlet Filter that wraps the original request in it if the target collection uses CGI Transforms.</para>
		</section>
		
		<section id="cgi-transforms-parsing">
			<title>Parsing the <literal>cgi_transform.cfg</literal> file</title>
			
			<para>
				Parsing the configuration file could be expensive and should'nt be done for each incoming request. Instead it's parsed just one time when loading the collection
				configuration, transformed in an in-memory object representation, and never parsed again (unless the collection config is reloaded).
			</para>
			
			<para>
				The object representation is basically a <literal>TransformRule</literal> object containing a <literal>Criteria</literal> and a list of <literal>Operation</literal>s.
				The parsing of each rule is done in a factory class, generating a list of <literal>TransformRule</literal> objects. Then, for each incoming request, the
				<literal>Criteria</literal> is tested for a match against the request parameters, and if it matches the <literal>Operation</literal>s are applied one after each other.
			</para>
			
			<para>
				This approach makes implementing a new type of rule easy. All you'll need to do is:
				<itemizedlist>
					<listitem>Decide the syntax in the <literal>cgi_transform.cfg</literal></listitem>
					<listitem>If needed, code the relevant <literal>Criteria</literal> to define how the rule is supposed to match</listitem>
					<listitem>Code the new <literal>Operation</literal> to apply the parameter transformation</listitem>
					<listitem>Update the parsing code to build the relevant <literal>Criteria</literal> and <literal>Operation</literal>s objects</listitem>
				</itemizedlist>
			</para>
		</section>
	</chapter>
	
	<chapter id="quicklinks">
		<title>Quick Links</title>
		
		<para>
			Nothing to fancy here: There is just an <literal>InputProcessor</literal> that reads the quick links configuration file and set the relevant query processor
			options depending on the configuration. On the output side there is nothing to do (except having the quicklinks tags correctly parsed).
		</para>
	</chapter>
	
	<chapter id="faceted-navigation">
		<title>Faceted navigation</title>
		
		<section>
			<title>Configuration</title>
			
			<section>
				<title>Configuration file locations</title>
				<para>
					A collection can have multiple <literal>faceted_navigation.(cfg|xml)</literal> configuration files:
					<itemizedlist>
						<listitem>A global one in <literal>conf/faceted_navigation.cfg</literal></listitem>
						<listitem>Per-profile ones in <literal>conf/&lt;profile&gt;/faceted_navigation.cfg</literal></listitem>
						<listitem>A global live one in <literal>data/&lt;collection&gt;live/idx/faceted_navigation.cfg</literal></listitem>
						<listitem>Per-profile live ones in <literal>data/&lt;collection&gt;live/idx/&lt;profile&gt;/faceted_navigation.cfg</literal></listitem>
					</itemizedlist>
					
					The ones in <literal>conf/</literal> should only be used by the Admin UI. The Public UI should use the ones in <literal>live/</literal> to acquire
					the faceted navigation settings.
					However a specific parameter named <literal>faceted_navigation.config.location=(conf|live)</literal> can be set to override the default behavior.
					That's why the Public UI has to load all these configuration files, and choose the right one at query time depending of the request parameters. 
				</para>
			</section>
			
			<section>
				<title>Parsing the configuration file</title>
				
				<para>
					In order to simplify the parsing code and to allow future extensions the <literal>faceted_navigation.cfg</literal> file is parsed using reflection: A Java class
					has been created for each category type, matching the tag names (<literal>MetadataFieldFill.java, QueryItem.java, ...</literal>). An instance of the correct class
					is instantiated each time a category time is found.
				</para>
				
				<para>
					In the same fashion, each &quot;extra&quot; property of some categories are set using reflection. Each category type as a default <literal>&lt;Data&gt;</literal>
					property, but some category types have extra properties such as &quot;Query&quot; for <literal>QueryItem</literal> types, or &quot;Metafield&quot; for
					<literal>XPathFill</literal>. When such a tag is encountered, the corresponding property is filled in the target category bean.
					To avoid multiple <literal>if/else</literal> to find the correct setter to call for the target class, the property is blindly set using a Spring <literal>BeanWrapper</literal>. 
				</para>
				
				<para>
					With this model, adding a new category type should be simple: Just add the correct Category class with the relevant properties, and it will get parsed automatically.
				</para>
			</section>
			
			<section>
				<title>Faceted navigation transform</title>
				
				<para>
					This feature originally allows the user to define an arbitrary Perl script to run to transform the results of the faceted navigation. The content of the facets and
					categories are passed to the script which is allowed to update the data model.
				</para>
				
				<para>
					This has been re-implemented as a Groovy script. To avoid the complexity of implementing an interface the script is an anonymous script to which a "facets" object is passed.
					This object is a list of <literal>com.funnelback.publicui.search.model.transaction.Facet</literal>. The Groovy script can update the content and does not have to return anything.
					An example of faceted navigation transform script could be:
					<programlisting language="java">
<![CDATA[import com.funnelback.publicui.search.model.transaction.*

for (Facet f: facets) {
    f.name = f.name + " (Groovy)"
}
]]>					
					</programlisting>
				</para>
			
			</section>
		</section>
	</chapter>
	
	<chapter id="hook-scripts">
		<title>Query transforms / hook scripts</title>
		
		<para>
			The Perl UI has the ability to use custom scripts for various purposes:
			<itemizedlist>
				<listitem>Query transforms: Update the query expression with an arbitrary Perl script (See the product doco for more details),</listitem>
				<listitem>
					Custom hook scripts: Since 10.1, a set of custom hook script can be defined per collection. This hook scripts will be called at various stages of the query lifecycle
					(See Confluence for more information).
				</listitem>
			</itemizedlist>
			
			Since these two features are similar I chose to merge them in a single feature: Custom per-collection Groovy hook scripts.
		</para>
		
		<para>
			Each collection can define a set of hook scripts (For now only "pre data fetch" and "post data fetch"). Depending of the Public UI application configuration of the query
			lifecycle, these hook scripts will get run.
		</para>
		
		<para>
			To add new hooks in the future, we'll have to:
			<itemizedlist>
				<listitem>Add a value to the <literal>com.funnelback.publicui.search.model.collection.Collection.Hook</literal> enum</listitem>
				<listitem>Update <literal>com.funnelback.publicui.search.lifecycle.GenericHookScriptRunner</literal> with relevant code for this hook (if needed)</listitem>
				<listitem>
					Update the application configuration (<literal>applicationContext.xml</literal>) to instantiate any relevant <literal>GenericHookScriptRunner</literal>
					on the correct phases.
				</listitem>
			</itemizedlist>
			
			<literal>GenericHookScriptRunner</literal> is a class that is able to run a given hook script, for a given phase (It implements <literal>InputProcessor</literal>, 
			<literal>OutputProcessor</literal> and <literal>DataFetcher</literal> so it's possible to use it in any phase)
		</para>
		
		<section>
		
		</section>
	</chapter>

</part>