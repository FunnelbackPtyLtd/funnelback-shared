<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en"
	xml:id="data-model" xmlns:xi="http://www.w3.org/2001/XInclude" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xlink="http://www.w3.org/TR/xlink"
	xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd">

	<title>Knowing the data model</title>

	<section>
		<title>NickScript vs. data model</title>
		<para>NickScript hide the underlying data model (The PADRE result packet) by using specific tags for specific purposes.</para>
		
		<para>
			For example the tag <code>&lt;s:AfterSearchOnly /&gt;</code> is an equivalent of testing if the <literal>&lt;results_summary&gt;/&lt;total_matching&gt;</literal>
			node of the data model contains <quote>0</quote> or not. In the same fashion, the <code>&lt;s:ResIf name="..." /&gt;</code> tag is an equivalent of
			testing the presence of a specific child node of the current <literal>&lt;results&gt;/&lt;result&gt;</literal> being processed.
		</para>
		
		<para>
			While it has the advantage of keeping things simple by not having to learn the data model, it's also very limited: If there isn't an existing
			tag for your use case you have to write a plug-in or rely on <code>EvalPerl</code>, and you have to learn the tags anyway. It also forces us to
            maintain a lot of <quote>simple</quote> tags for basic if/else statements (All the <literal>*If*</literal> tags).
		</para>	
		
		<para>
			Choosing to use an existing template engine instead of re-implementing NickScript changes that approach: Because these template engines are generic
			by design there can't be a business domain context specific tags such as <quote><code>&lt;s:AfterSearchOnly /&gt;</code></quote>. Instead the template engine
			provides a way to test for the presence of a node in the data model, typically:
			<code>{#if PADRE_result_packet.results_summary.total_matching &gt; 0}...{/#if}</code>.
		</para>
		
		<para>
			With this approach users will have to learn the data model. It's not very different of learning a set of specific NickScript tags and it has some
			advantages: Once you've understand the data model you practically can do anything with it, instead of being constrained to a set of specific tags
            and having to learn new tags to do new things. By using generic tags you can for instance implement any condition checking directly in your template
            without having to write a plug-in for it.
		</para>
	</section>
	
	<section>
		<title>Helping with tools</title>
		
		<para>
			If learning the data model is a problem, we can also look at solutions to help the form files designers, beyond the template engine itself.
			For example it could be very convenient to have an example of data model on your screen when you design a form file, and perhaps be able to
			drag 'n drop nodes of it into your template file ?
			
			<mediaobject>
				<imageobject>
					<imagedata fileref="resources/mockup-datamodel.png" format="PNG" align="center" width="100%"/>
				</imageobject>
				<caption>
					<para>
						This mock-up shows a possible form design tool: On the left there is the form editor, pretty similar to the one we already have,
						on the right there is a preview of the data model for a specific search. The user can pick a node in the data model and drop it on
						his form. Depending of the type of node he picked it generates different form tags (A list iteration tag, a placeholder to display
						the value, etc.)
					</para>
				</caption>
			</mediaobject>
			
		</para>
	</section>
</chapter>
