<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en"
	xml:id="data-model" xmlns:xi="http://www.w3.org/2001/XInclude" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xlink="http://www.w3.org/TR/xlink"
	xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd">

	<title>Knowing the data model</title>

	<section>
		<title>NickScript vs. data model</title>
		<para>NickScript hide the underlying data model (The PADRE result packet) by using specific tags for specific purposes.</para>
		
		<para>
			For example the tag <code>&lt;s:AfterSearchOnly /&gt;</code> is an equivalent of testing if the <literal>results_summary/total_matching</literal>
			node of the data model contains <quote>0</quote> or not. In the same fashion, the <code>&lt;s:ResIf name="..." /&gt;</code> tag is an equivalent of
			testing the presence of a specific child node of the current <literal>results/result</literal> being processed.
		</para>
		
		<para>
			While it has the advantage of keeping things simple by not having to learn the data model, it's also very limited: If there isn't an existing
			tag for your use case you have to write a plugin or rely on <code>EvalPerl</code>.
		</para>	
		
		<para>
			Choosing to use an existing template engine instead of re-implementing NickScript changes that approach: Because these template engines are generic
			by design there can't be a specific search-context <code>&lt;s:AfterSearchOnly /&gt;</code> tag. Instead the template engine provides a way to test
			for the presence of a node in the data model, typically: <code>{#if PADRE_result_packet.results_summary.total_matching &gt; 0}...{/#if}</code>.
		</para>
		
		<para>
			With this approach users will have to learn the data model. It's not very different of learning a set of specific NickScript tags and it has some
			advantages: Once you've understand the data model you practically can do anything with it, instead of being constrained to a set of specific tags.
			By using generic tags you can for instance implement any condition checking directly in your template without having to write a plugin for it.
		</para>
	</section>
	
	<section>
		<title>Helping with tools</title>
		
		<para>
			If learning the data model is a problem, we can also look at solutions to help the form files designers, beyond the template engine itself.
			For example it could be very convenient to have an example of data model on your screen when you design a form file, and perhaps be able to
			drag 'n drop nodes of it into your template file ?
			
			<mediaobject>
				<imageobject>
					<imagedata fileref="resources/mockup-datamodel.png" format="PNG" align="center" width="100%"/>
				</imageobject>
				<caption>
					<para>
						This mock-up shows a possible form design tool: On the left the form editor, pretty similar to the we already have, on the right
						a preview of the data model for a specific search. The user can pick a node in the data model and drop it on his form. Depending of the
						type of node he picked it generates different form tags.
					</para>
				</caption>
			</mediaobject>
			
		</para>
	</section>
</chapter>
