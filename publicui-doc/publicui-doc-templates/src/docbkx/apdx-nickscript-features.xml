<?xml version="1.0" encoding="UTF-8"?>
<appendix xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en"
    xml:id="appendix-a" xmlns:xi="http://www.w3.org/2001/XInclude" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xlink="http://www.w3.org/TR/xlink"
    xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd">

    <title>NickScript features requiring custom implementation</title>

    <para>
        Most of the NickScript tags purpose is to give access to the data model (Ex: <code>&lt;s:Res&gt;title&lt;/s:Res&gt;</code>)
        or to test presence / values of this model.
    </para>
    
    <para>
        Accessing the data model is the core of any template engine so any engine will provide that out of the box, however some other
        tags have special behavior that we'll need to re-implement. I've listed them in a table below.
    </para>

    <para>
        The following tags just give access to the data model and won't be listed in the table:
        <simplelist>
            <member><code>s:ResultData</code>, <code>s:Results</code>, <code>s:Res</code>, <code>s:Explore</code></member>
            <member><code>s:QuickLinks</code>, <code>s:BestBets</code>, <code>s:ContextualNavigation</code> and children, <code>s:FacetedSearch</code> and children</member>
            <member><code>s:QueryClean</code></member>
            <member><code>s:Date</code></member>
            <member><code>s:CheckSpelling</code></member>
        </simplelist>
        
        The following tags test conditions against the data model and won't be listed in the table:
        <simplelist>
            <member><code>s:InitialFormOnly</code>, <code>s:AfterSearchOnly</code>:  corresponds to testing <literal>response.resultPacket.resultsSummary.totalMatching</literal>.</member>
            <member><code>s:IfDefCGI</code>, <code>s:IfNotDefCGI</code>: corresponds to testing the equivalent data field in the model.</member>
            <member><code>s:Compare</code>: corresponds to comparing directly the specific data field in the model.</member>
            <member><code>s:ResIf</code>, <code>s:ResIfNot</code>, <code>bbif</code>, <code>bbifnot</code>: corresponds to testing directly the specific data field presence in the model.</member>
            <member><code>s:ResIfCollection</code>, <code>s:ResIfNotCollection</code>: corresponds to testing the <emphasis>component</emphasis> field of the result data.</member>
        </simplelist>
        
        The following tags format data and won't be listed in the table, as they can be re-implemented using the formatting
        capabilities of the template engine:
        <simplelist>
            <member><code>s:Truncate</code>, <code>s:TruncateURL</code>, <code>s:Cut</code></member>
            <member><code>s:Boldicize</code>, <code>s:Italicize</code></member>
            <member><code>s:Commify</code></member>
            <member><code>s:URLEncode</code>, <code>s:HtmlDecode</code></member>
        </simplelist>
    </para>

    <para>
        <table>
            <title>NickScript features to be re-implemented</title>
            <tgroup cols="2">
            
                <thead>
                    <row>
                        <entry>Tag</entry>
                        <entry>Purpose</entry>
                        <entry>Replacement</entry>
                    </row>
                </thead>
                    
                <tbody>
                    <row>
                        <entry><code>s:cfg</code>, <code>s:FormChoice</code></entry>
                        <entry>Access collection config parameter</entry>
                        <entry>The collection config is embedded in the model, thus accessing config data is possible. Shouldn't need to be re-implemented.</entry>
                    </row>
                    <row>
                        <entry><code>s:cgi</code></entry>
                        <entry>Access CGI parameters</entry>
                        <entry>Most (if not all) of the CGI variables are available in the model. Shouldn't need to be re-implemented.</entry>
                    </row>
                    <row>
                        <entry><code>s:CurrentDate</code></entry>
                        <entry>Displays current date</entry>
                        <entry>Either use a built-in feature of the template engine, or embed a <quote>current date</quote> field into the model.</entry>
                    </row>
                    <row>
                        <entry><code>s:env</code></entry>
                        <entry>Access environment variables</entry>
                        <entry>Was specific to Perl technology, shouldn't be used anymore.</entry>
                    </row>
                    <row>
                        <entry><code>s:IncludeFile</code></entry>
                        <entry>Include the content of a file</entry>
                        <entry>This needs to be re-implemented with a custom directive or plug-in.</entry>
                    </row>
                    <row>
                        <entry><code>s:rss</code>, <code>s:OpenSearch</code></entry>
                        <entry>Provide a RSS link to <literal>rss.cgi</literal> for a query term, or generate an OpenSearch snippet.</entry>
                        <entry>
                            Those tags are more <quote>helpers</quote> that generate an HTML snippet, than tags containing logic. It should be
                            possible either to embed the content directly in the page, or to use a <quote>sub template</quote> mechanism to re-factor them.
                        </entry>
                    </row>
                    <row>
                        <entry><code>s:CustomText</code></entry>
                        <entry>Display the custom text related to a query transform.</entry>
                        <entry>This has been superseded by a hook mechanism.</entry>
                    </row>
                    <row>
                        <entry>
                            <code>s:TierBarFullyMatching</code>,
                            <code>s:TierBarPArtiallyMatching</code>,
                            <code>s:TierBarBestBets</code>,
                            <code>s:TierBarEventDate</code>
                        </entry>
                        <entry>Format appearance of tier bars</entry>
                        <entry>
                            All the data needed by these tags are present in the model. They could either be implemented directly into
                            the form file or with <quote>sub templates</quote>.
                        </entry>
                    </row>
                    <row>
                        <entry><code>s:Select</code></entry>
                        <entry>Helper / utility to build <literal>&lt;select ... /&gt;</literal> HTML elements</entry>
                        <entry>
                            <para>Will need to be re-implemented as some sort of plug-in.</para>
                            <note>
                                <para>
                                    This will cause problem with non-classic template engine like the logic-less one, because everything is supposed
                                    to be embedded in the model, which will obviously be difficult in case of HTML select form data.
                                </para>
                            </note>
                        </entry>
                    </row>
                    <row>
                        <entry><code>s:PrevNext</code></entry>
                        <entry>Display previous / next page links</entry>
                        <entry>
                            Will have to be re-implemented as a plug-in. While the corresponding data is contained in the model the logic is too complex
                            to be embedded directly into each form file.
                        </entry>
                    </row>
                    <row>
                        <entry><code>s:EvalPerl</code></entry>
                        <entry>It's evil, don't use it</entry>
                        <entry>
                            Most of the uses cases of <code>s:EvalPerl</code> can be replaced by using formatting functions, however the template engine
                            should provide a way to run arbitrary code, ideally with a plug-in system to keep things clean.
                        </entry>
                    </row>
                    
                </tbody>
            </tgroup>
        </table>
    
    </para>
    
</appendix>
