<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en"
	xml:id="alternate-solutions" xmlns:xi="http://www.w3.org/2001/XInclude" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xlink="http://www.w3.org/TR/xlink"
	xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd">

	<title>Alternate solutions</title>

	<para>
		Investigating alternate solution is done on multiple criteria:
		<simplelist>
			<member>Which underlying technology could we use to replace Perl ?</member>
			<member>Which approach could we take instead of defining form tags ?</member>
		</simplelist>
	</para>

	<section>
		<title>Javascript based engine</title>
		
		<para>
			Javascript <abbrev >(JS)</abbrev> based template engines have recently become very popular, the most popular ones probably being
			<ulink url="http://api.jquery.com/category/plugins/templates/">jQuery templates</ulink>	(Initially developed by Microsoft) and
			<ulink url="https://github.com/janl/mustache.js">mustache.js</ulink> (Used on the new Twitter).
		</para>
		
		<para>
			Using a JS based template engine has several advantages, as suggested by Matt:
			<simplelist>
				<member>It's based on a well-known language used by web developers, which is the target audience for form files development,</member>
				<member>
					Using JS means that we could do the page rendering on the <emphasis>client-side</emphasis> (Browser). That could allows us to
					save some server processing time, as well as provide <quote>ajaxy</quote> features such as an instant-search.
				</member>
				<member>
					We can of course keep the default rendering process server-side, using a JS runtime for Java such as
					<ulink url="http://www.mozilla.org/rhino/">Mozilla Rhino</ulink>. This dual client/server capability means that we could
					use the same form files both server-side or client-side, with only minor modifications.
				</member>
				<member>
					In the Squiz/PHP perspective there seems to be some PHP JS runtimes, in the same fashion of Rhino for Java (See for example
					<ulink url="http://phpjs.berlios.de/">phpjs</ulink> or <ulink url="http://j4p5.sourceforge.net/">j4p5</ulink>). That means
					that we could re-use the same form files in Squiz too.
				</member>
			</simplelist>
			
			However it also has its drawbacks:
			<itemizedlist>
				<listitem>
					<para>
						The Javascript interpreter/compiler, both on client side or server side, is generally not very verbose. It's difficult to get clear
						error messages. This is important when developing form files, because if you do something wrong you'd like to get the exact line number
						<emphasis>of your form file</emphasis> causing the error.
					</para>
					<para>
						I observed during my experiments that when running a JS template engine with Rhino on the server side, if I did a syntax error on my
						form file, it wasn't caught until the template gets interpreted and the error generated was an execution error coming from the code of
						the template engine. The line number I got was from the template engine JS file, not my form file, which makes things difficult to fix.
					</para>
				</listitem>
				<listitem>
					<para>
						Running Rhino on the server side can have a performance cost. I didn't benchmark it properly as in this experimental phase I didn't develop
						the infrastructure to re-compile form files only when they changed and keep an already-compiled version (I recompiled them for every request).
						However even in this mode the performance didn't seem to bad (about 10ms to render a template).
					</para>
				</listitem>
			</itemizedlist>
		</para>
	</section>

	<section>
		<title>Logic less template engine</title>
		
		<para>
			A template system purpose is to separate the application logic from the data presentation. However in most of the template engines you can implement
			some application logic using directives such as if/else, loops or logical comparison. That means that your data model is somehow processed in the
			<quote>presentation</quote> part of your application, and that your templates contains <emphasis>code</emphasis>, which doesn't fully enforce the original
			template system paradigm. 
		</para>
		<para>
			A new approach to templates has emerged recently, with the leader in this movement being <ulink url="https://mustache.github.com/">Mustache</ulink>. This
			new approach is to provide a template engine with no logic possibility at all: No if/else statement, no flexible looping, no comparison operators, no formatting
			directives. This approach assumes that the data has been fully processed, prepared and formatted, and is ready to <emphasis>just</emphasis> be displayed.
		</para>
		
		<para>Let's illustrate with an example taken from the Mustache doco. Consider the following template:
			<programlisting><![CDATA[
Hello {{name}}
You have just won ${{value}}!
{{#in_ca}}
	Well, ${{taxed_value}}, after taxes.
{{/in_ca}}
			]]></programlisting>
			
			And the following data model:
			<programlisting><![CDATA[
{
  "name": "Chris",
  "value": 10000,
  "taxed_value": 10000 - (10000 * 0.4),
  "in_ca": true
}
			]]></programlisting>
			
			Resulting in:
			<programlisting>
<![CDATA[Hello Chris
You have just won $10000!
Well, $6000.0, after taxes.]]>
			</programlisting>
		</para>
		
		<para>
			The logic of deciding whether or not the tax applies (<code>in_ca</code>) and calculating the taxed value is embedded in the <emphasis>data model</emphasis>,
			and not in the template. For instance with a classic template engine we would probably have written:
			<programlisting><![CDATA[
You have won $<%= value %>!
<% if ( in_ca == true) { %>
	Well, $<%= value - (value * 0.4) %>, after taxes.
<% } %>
			]]></programlisting>
			
			This syntax clearly embeds some business rules in the template.
		</para>
		
		<para>
			Pros:
			<itemizedlist>
				<listitem>
					<para>
						No possibility to embed logic into the templates: This separation of concerns guarantees that templates are kept simple and are independent of any
						underlying logic implementation (Could be Java, Javascript, PHP, ...),
					</para>
				</listitem>
				<listitem><para>Templates are easy to read, and can be written by non-developer people (web designers).</para></listitem>
			</itemizedlist>
			
			Cons:
			<itemizedlist>
				<listitem>
					<para>
						Sometimes it's convenient to embed a bit of logic in the templates, at least to do simple things like if/else statements. The typical example in
						our form file is the <quote>Cached</quote> link: If the file type is pdf,doc,xls or ppt we display a <quote>View as HTML</quote> link below the title
						instead of the usual <quote>Cached</quote> link at the bottom of the result block. Reproducing that with a logic-less engine requires to code a specific
						function and apply it to the data model. For example, with the following template:
						<programlisting><![CDATA[
<li>
	<h3>
		<a href="{{liveUrl}}">{{title}}</a>
	</h3>

	{{#html_view_link}}
		<p class="fb-file-format">
			<span>{{fileSize}} - {{fileTypeLabel}}</span>
			<a href="{{cacheLink}}">View as HTML</span>
	{{/html_view_link}}
	
	...
	<p>
		<cite>{{displayUrl}}</cite>
		
		<!-- '^' is used to negate a section -->
		{{^html_view_link}}
			- <a href="{{cacheLink}}">Cached</a>
		{{/html_view_link}}
	</p>
</li>
						]]></programlisting>
						
						And the following data model:
						<programlisting><![CDATA[
{
  "liveUrl"        : "http://server/click.cgi?url=...",
  "displayUrl"     : "http://test-data.funnelback.com/Shakespeare/lear/full.pdf",
  "title"          : "King Lear: List of scenes",
  "html_view_link" : function() { return fileType.matches(/\.(pdf|doc|ppt|xls)$/); },
  "fileSize"       : 123456,
  "fileTypeLabel"  : function () {
                           switch(fileType) {
                               case "pdf":
                                   return "PDF";
                                   break;
                               case "doc":
                                   return "Microsoft Word";
                                   break;
                                   // ...
                           }
                       },
	"cacheLink"      : "http://server/cache.cgi..."
}						
						]]></programlisting>
					</para>
				</listitem>
				<listitem>
					<para>
						As we can't repeat these functions in every form files that means that we must provide a function library to do everything NickScript currently
						does, such as the aforementionned example, or previous / next links, etc. Having to develop this library is not as costly as having to roll our own
						templating engine, but it's still code we have to maitain, losing a bit the benefit of using a third-party templating engine.
					</para>
				</listitem>
			</itemizedlist>
		</para>
	</section>
	
	<section>
		<title>Directive-less engines</title>
		
		<para>
			Most templating engines provide their own directives, that you have to learn. For example <code>&lt;s:ResIf&gt;...&lt;/s:ResIf&gt;</code> for NickScript, or
			<code>&lt;#if&gt;...&lt;/#if&gt;</code> for Freemarker. But some templating engines don't provide that kind of directives and rely entirely on embedded snippets
			of the underlying language. For instance, consider the following example:
			<programlisting><![CDATA[
<% if (response.resultPacket.spell) { %>
  <!-- Did you mean...? -->
  <span id="fb-spelling">
    Did you mean <a href="<%= response.resultPacket.spell.url %>"><%= response.resultPacket.spell.text %></a> ?
  </span>
<% } %>

...

<% if (response.resultPacket.results && response.resultPacket.results.length > 0) {
  for (var i=0; i<response.resultPacket.results.length; i++) {
    var result = response.resultPacket.results[i]; %>
    
    <!-- EACH RESULT -->
    <li class="result">
      <h3>
        <% if (result.fileType != 'html') { %>
          <span class="fb-filetype fb-<%= result.fileType %>">[<%= result.fileType.toUpperCase() %>]&nbsp;</span>
        <% } %>
        <a href="<%= result.displayUrl %>" title="<%= result.liveUrl %>"><%= result.title %></a>
      </h3>
      
      ...
      
    </li>
  <% } // end for %>
<% } // end if %>
		]]></programlisting>
		</para>
		
		<para>
			Pros:
			<simplelist>
				<member>There is nothing to learn (Assuming you already know the underlying language, Javascript in the previous example),</member>
				<member>It's flexible: You have access to every capability of the underlying language, instead of being constrained to a set of directives.</member>
			</simplelist>
			
			Cons:
			<simplelist>
				<member>Templates clearly mix presentation and logic, which is generally not a good idea,</member>
				<member>Having these opening/closing tags <code>&lt;% ... %&gt;</code> make things difficult to read,</member>
				<member>Changing the underlying technology breaks all the existing forms.</member>
			</simplelist>
		</para>
	</section>
	
</chapter>
